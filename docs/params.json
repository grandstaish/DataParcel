{
  "name": "PaperParcel",
  "tagline": "Android Parcelable boilerplate annotation processor ",
  "body": "# PaperParcel\r\n\r\n[![Build Status](https://travis-ci.org/grandstaish/paperparcel.svg?branch=master)](https://travis-ci.org/grandstaish/paperparcel)\r\n\r\n## Overview\r\n\r\nPaperParcel is an annotation processor that automatically generates the `CREATOR` and `writeToParcel(...)` implementations for you when writing [Parcelable](http://developer.android.com/intl/es/reference/android/os/Parcelable.html) objects. PaperParcel fully supports both Java and Kotlin (including [Kotlin Data Classes](https://kotlinlang.org/docs/reference/data-classes.html)). Additionally, PaperParcel supports Google's [AutoValue](https://github.com/google/auto/tree/master/value) via an [AutoValue Extension](http://jakewharton.com/presentation/2016-03-08-ny-android-meetup/).\r\n\r\nOut of the box, PaperParcel supports all of the types that are supported by the [Parcel](https://developer.android.com/reference/android/os/Parcel.html) class, including a few minor additions (e.g. `java.util.Set`). Support for any other types can be added using custom [TypeAdapters](README.md#typeadapters).\r\n\r\n## Usage \r\n\r\nUsing PaperParcel is easy, the API is extemely minimal. Let's look at an example:\r\n\r\n``` java\r\n@PaperParcel // (1)\r\npublic class User implements Parcelable { \r\n  public static final Creator<User> CREATOR = PaperParcelUser.CREATOR; // (2)\r\n\r\n  public long id; // (3)\r\n  public String firstName; // (3)\r\n  public String lastName; // (3)\r\n\r\n  @Override public int describeContents() {\r\n    return 0;\r\n  }\r\n\r\n  @Override public void writeToParcel(Parcel dest, int flags) {\r\n    PaperParcelUser.writeToParcel(this, dest, flags); // (4)\r\n  }\r\n}\r\n```\r\n\r\nI've annotated each important part with a comment and a number, let's look at each of these one by one:\r\n\r\n**1)** Annotating a class with `@PaperParcel` will automatically generate the `CREATOR` and `writeToParcel(...)` implementations for that class at compile time. These implementations are generated into a java class (in the same package as your model) called `PaperParcel$CLASS_NAME$`\r\n\r\n**2)** This is the first usage of the generated code — the generated `CREATOR` instance. \r\n\r\n**3)** These are the fields that will be processed by PaperParcel.\r\n\r\n**4)** This is the second usage of the generated code — the generated `writeToParcel(...)` implementation.\r\n\r\n## Even Easier; Use The AutoValue Extension\r\n\r\nIf you are already using AutoValue, all you need to do is simply add `implements Parcelable` to your AutoValue object and that's it:\r\n\r\n``` java\r\n@AutoValue \r\npublic abstract class User implements Parcelable { \r\n  public abstract long id(); \r\n  public abstract String firstName(); \r\n  public abstract String lastName(); \r\n\r\n  public static User create(long id, String firstName, String lastName) {\r\n    return new AutoValue_User(id, firstName, lastName);\r\n  }\r\n}\r\n```\r\n\r\n## Kotlin\r\n\r\nUsage is exactly the same as java:\r\n\r\n``` kotlin\r\n@PaperParcel\r\ndata class User(\r\n    val id: Long,\r\n    val firstName: String,\r\n    val lastName: String\r\n) : Parcelable {\r\n  companion object {\r\n    @JvmField val CREATOR = PaperParcelUser.CREATOR\r\n  }\r\n  \r\n  override fun describeContents() = 0\r\n\r\n  override fun writeToParcel(dest: Parcel, flags: Int) {\r\n    PaperParcelUser.writeToParcel(this, dest, flags)\r\n  }\r\n}\r\n```\r\n\r\n**Optional:** If you don't mind a minor amount of reflection, the `paperparcel-kotlin` module provides [PaperParcelable](paperparcel-kotlin/src/main/java/paperparcel/PaperParcelable.kt). `PaperParcelable` is an interface with default implementations written for `describeContents` and `writeToParcel(...)` so you don't have to write them yourself, e.g.:\r\n\r\n``` kotlin\r\n@PaperParcel\r\ndata class User(\r\n    val id: Long,\r\n    val firstName: String,\r\n    val lastName: String\r\n) : PaperParcelable {\r\n  companion object {\r\n    @JvmField val CREATOR = PaperParcelUser.CREATOR\r\n  }\r\n}\r\n```\r\n\r\n## TypeAdapters\r\n\r\nPaperParcel keeps it built-in `TypeAdapter`s list minimal to ensure the library is as small as possible. If you want to extend the type system, you can do this by registering your own custom `TypeAdapter`. Defining a custom `TypeAdapter` is simple, let's look at an example that adds support for the `java.util.Date` class:\r\n\r\n``` java\r\n@RegisterAdapter // 1\r\npublic final class DateAdapter implements TypeAdapter<Date> { \r\n  public static final DateAdapter INSTANCE = new DateAdapter(); // 2\r\n\r\n  @NonNull @Override public Date readFromParcel(@NonNull Parcel source) {\r\n    return new Date(source.readLong()); \r\n  }\r\n  \r\n  @Override public void writeToParcel(@NonNull Date value, @NonNull Parcel dest, int flags) {\r\n    dest.writeLong(value.getTime()); \r\n  }\r\n}\r\n```\r\n\r\nI've annotated each important part with a comment and a number, let's look at each of these one by one:\r\n\r\n**1)** This is how you register your custom adapter with the compiler — just by annotating this class, generated code will now use `UuidAdapter` when reading and writing `UUID` fields.\r\n\r\n**2)** This is a completely optional singleton instance. If PaperParcel notices your class is a singleton, it will use the singleton instance. This helps greatly in preventing unecessary allocations. For this reason, most of the built-in type adapters are singletons. Note for Kotlin users, this is equivalent to defining your Adapter as an `object`.\r\n\r\nMany similar projects also use some variant of `TypeAdapter`, however the PaperParcel implementation is slightly more flexible. PaperParcel allows `TypeAdapter`s to be [composable](https://en.wikipedia.org/wiki/Object_composition) and [generic](https://docs.oracle.com/javase/tutorial/java/generics/types.html). To see why this is useful, let's look at how PaperParcel's [SparseArrayAdapter](paperparcel/src/main/java/paperparcel/internal/SparseArrayAdapter.java) is defined:\r\n\r\n```java\r\npublic final class SparseArrayAdapter<T> implements TypeAdapter<SparseArray<T>> {\r\n  private final TypeAdapter<T> itemAdapter;\r\n\r\n  public SparseArrayAdapter(TypeAdapter<T> itemAdapter) {\r\n    this.itemAdapter = itemAdapter;\r\n  }\r\n  ...\r\n}\r\n```\r\n\r\nAs you can see, `SparseArrayAdapter` has a dependency on another `TypeAdapter` to handle the parcelling of its items, but the item type is not hard-coded (it is generic). This means we don't need to define a new adapter class each time we use a `SparseArray` with a different item type, instead this single adapter will handle all item types. \r\n\r\nA `TypeAdapter` can list any number of `TypeAdapter` or `Class` dependencies as constructor parameters and PaperParcel will resolve them at compile time. You can take advantage of this power to easily add support for container types that don't come out of the box, e.g. `RealmList` for [Realm](https://github.com/realm/realm-java), various non-java `Collection` and `Tuple` types in [Kotlin](https://github.com/JetBrains/kotlin/), or even `ImmutableMap` for [Guava](https://github.com/google/guava). \r\n\r\n## Excluding Fields\r\n\r\nBy default, PaperParcel will exclude any `static` or `transient` fields from being included in the generated `CREATOR` and `writeToParcel(...)` implementations. If you have more complicated requirements for excluding fields, then you can customise this behaviour using the `@PaperParcel.Options` API:\r\n\r\n#### Exclude via modifiers\r\n\r\nLet's say you wanted to exclude all `transient` and `static final` fields (therefore keeping any non-final `static` field). You could achieve that like this:\r\n\r\n```java\r\n@PaperParcel\r\n@PaperParcel.Options(\r\n  excludeModifiers = { \r\n    Modifier.TRANSIENT, \r\n    Modifier.STATIC | Modifier.FINAL \r\n  }\r\n)\r\npublic class Example implements Parcelable {\r\n  static final int field1 = 0; // Will not be parcelled\r\n  static int field2; // Will be parcelled\r\n  transient int field3; // Will not be parcelled\r\n  int field4; // Will be parcelled\r\n  ...\r\n}\r\n```\r\n\r\n#### Exclude via annotation\r\n\r\nAnother API available to you is `excludeAnnotations`. This API lists all of the annotations that will be used to exclude fields. Let's see how this might look:\r\n\r\nFirst we'll create an annotation and call it `Exclude`:\r\n\r\n```java\r\n@Retention(RetentionPolicy.SOURCE)\r\n@Target(ElementType.FIELD)\r\npublic @interface Exclude {\r\n}\r\n```\r\n\r\nNow we can use this annotation in any of our model classes to exclude fields like so:\r\n\r\n```java\r\n@PaperParcel\r\n@PaperParcel.Options(excludeAnnotations = Exclude.class)\r\npublic class Example implements Parcelable {\r\n  int field1; // Will be parcelled\r\n  @Exclude int field2; // Will not be parcelled\r\n  ...\r\n}\r\n```\r\n\r\n#### Opt-in field strategy\r\n\r\nLastly, PaperParcel can be configured to ignore all fields unless specified otherwise. This is useful in a style of programming where you want to explicitly specify all fields that should be considered for parcelling.\r\n\r\nLike the previous example, we can define our own annotation:\r\n\r\n```java\r\n@Retention(RetentionPolicy.SOURCE)\r\n@Target(ElementType.FIELD)\r\npublic @interface Expose {\r\n}\r\n```\r\n\r\nThen our `@Expose` annotation can be used to include individual fields like so:\r\n\r\n```java\r\n@PaperParcel\r\n@PaperParcel.Options(\r\n  excludeNonExposedFields = true,\r\n  exposeAnnotations = Expose.class\r\n)\r\npublic class Example implements Parcelable {\r\n  @Expose int field1; // Will be parcelled\r\n  int field2; // Will not be parcelled\r\n  ...\r\n}\r\n```\r\n\r\n### Reusable exclusion rules\r\n\r\nApplying exclusion rules in this manner can become tedius if you if you want to apply the same rules to many (or all) of your model objects. For a more reusable strategy, you may wish to create a custom annotation which will define all of the rules you wish to apply; then use your custom annotation on your `@PaperParcel` classes instead. Here's an example of a custom annotation that has `@PaperParcel.Options` applied to it:\r\n\r\n```java\r\n@PaperParcel.Options(...) // Define your rules here\r\n@Retention(RetentionPolicy.SOURCE)\r\n@Target(ElementType.TYPE)\r\npublic @interface MyOptions {\r\n}\r\n```\r\n\r\nAfter defining `@MyOptions` (call it whatever you like), you can then apply it directly to any `@PaperParcel` class to apply the rules:\r\n\r\n```java\r\n@MyOptions\r\n@PaperParcel\r\npublic class Example implements Parcelable {\r\n  ...\r\n}\r\n```\r\n\r\n## Model Conventions\r\n\r\n*Note: this section is only relevant if you are using PaperParcel without the assitance of AutoValue or Kotlin's data classes.*\r\n\r\nBy default, PaperParcel uses no reflection to access fields<sup id=\"a1\">[1](#footnote-reflect-annotations)</sup>. Because of that, all of the fields that PaperParcel is going to process need to follow a few loose conventions in order for PaperParcel to know how to read your fields and re-instantiate your models. Any failure to follow these conventions will result in a compile time error with a clear message informing you of what is wrong.\r\n\r\n#### Reading Fields\r\n\r\nThe easiest way for PaperParcel to read a field is for it to be non-private. Because the generated code lies in the same package as the model itself, `default`, `protected`, or `public` fields can be read directly. \r\n\r\nHowever private fields are common practice and need to be supported. Therefore, if a field is private, PaperParcel will look for an accessor method (AKA a getter method) for that field. PaperParcel relies on the following conventions to find accessor methods:\r\n\r\n**1)** The method needs to return an assignable type to the field's type\r\n\r\n**2)** The method needs to have no arguments\r\n\r\n**3)** The method needs to have one of the following names: `$FIELD_NAME$`, `get$FIELD_NAME$`, or `is$FIELD_NAME$`. For example, if the field is named `firstName`, then the set of valid accessor method names would contain `firstName`, `getFirstName`, and `isFirstName`.\r\n\r\n#### Writing Fields\r\n\r\nThe easiest way for PaperParcel to write a field is for it to be non-private and non-final. Because the generated code lies in the same package as the model itself, `default`, `protected`, or `public` fields can be written directly. \r\n\r\nAs already mentioned, private fields to be supported. Therefore, if a field is private, PaperParcel will look for either a corresponding constructor arugment for the field, or a setter method for the field.\r\n\r\nConstructor arugments are simple: they must have the same name as the field that it is assigning. In addition, the argument type must be assignable to the field type. \r\n\r\nSetter methods are discovered using similar conventions to the aforementioned accessor method conventions:\r\n\r\n**1)** The method needs to have one argument \r\n\r\n**2)** The argument type needs to be assignable to the field's type\r\n\r\n**3)** The method needs to have one of the following names: `$FIELD_NAME$`, or `set$FIELD_NAME$`. For example, if the field is named `firstName`, then the set of valid setter method names would contain `firstName` and `setFirstName`.\r\n\r\n##\r\n\r\n<sub><b><a name=\"footnote-reflect-annotations\">1</a></b>: You can configure PaperParcel to access private fields via refelection using the `PaperParcel.Options#reflectAnnotations()` API. [↩](#a1)</sub>\r\n\r\n## Download\r\n\r\n**Java:**\r\n\r\n```groovy\r\ndependencies {\r\n  compile 'nz.bradcampbell:paperparcel:2.0.0-SNAPSHOT'\r\n  annotationProcessor 'nz.bradcampbell:paperparcel-compiler:2.0.0-SNAPSHOT'\r\n}\r\n```\r\n\r\n**Kotlin:**\r\n\r\nPaperParcel requires `kapt2` and `kotlin 1.0.5` or greater. To use `kapt2`, apply the `kotlin-kapt` gradle plugin to your app's `build.gradle` file.\r\n\r\n```groovy\r\napply plugin: 'kotlin-kapt'\r\n\r\ndependencies {\r\n  compile 'nz.bradcampbell:paperparcel:2.0.0-SNAPSHOT'\r\n  compile 'nz.bradcampbell:paperparcel-kotlin:2.0.0-SNAPSHOT' // Optional\r\n  kapt 'nz.bradcampbell:paperparcel-compiler:2.0.0-SNAPSHOT'\r\n}\r\n```\r\n\r\nDevelopment snapshots are available on [JFrog OSS Artifactory](https://oss.jfrog.org/oss-snapshot-local).\r\n\r\n## Contributing\r\n\r\nIf you would like to contribute code you can do so by forking the repository and sending a pull request.\r\n\r\nWhen submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code compiles by running `gradlew clean build`.\r\n\r\n## License\r\n    Copyright 2016 Bradley Campbell.\r\n    \r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n       http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}